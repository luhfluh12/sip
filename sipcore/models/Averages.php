<?php

/**
 * This is the model class for table "averages".
 *
 * The followings are the available columns in table 'averages':
 * @property integer $id
 * @property integer $subject
 * @property integer $student
 * @property integer $schoolyear
 * @property integer $semester
 * @property integer $added
 * @property integer $type
 * @property integer $date
 * 
 * 
 * The followings are the available model relations:
 * @property Subjects $rSubject
 * @property Students $rStudnet
 */
class Averages extends CActiveRecord
{
        const SMS_POINTS = 3; // max points the avg can decrase without sms
        const LOW_AVERAGE = 4.5; // minimum allowed average to pass the class
        
        const TYPE_CHART=0; // averages generated to show the chart
        const TYPE_CHART_THESIS=4; // averages generated by adding the thesis, for the chart
        const TYPE_OFFICIAL = 1;// medie semestriala oficiala (e in catalog)
        const TYPE_YEARLY = 2; // medie generala de sfarsit de an scolar
        const TYPE_EXAM = 3; // examen corigenta
	/**
	 * Returns the static model of the specified AR class.
	 * @return Averages the static model class
	 */
	public static function model($className=__CLASS__)
	{
		return parent::model($className);
	}

	/**
	 * @return string the associated database table name
	 */
	public function tableName()
	{
		return 'averages';
	}

	/**
	 * @return array validation rules for model attributes.
	 */

        /**
	 * @return array relational rules.
	 */
	public function relations()
	{
		// NOTE: you may need to adjust the relation name and the related
		// class name for the relations automatically generated below.
		return array(
			'rSubject' => array(self::BELONGS_TO, 'Subject', 'subject'),
			'rStudent' => array(self::BELONGS_TO, 'Student', 'student'),
		);
	}

	/**
	 * @return array customized attribute labels (name=>label)
	 */
	public function attributeLabels()
	{
		return array(
			'id' => 'ID',
			'subject' => 'Materie',
			'student' => 'Elev',
			'schoolyear' => 'An școlar',
			'semester' => 'Semestru',
			'added' => 'Adăugat',
                        'date' => 'Data din catalog',
		);
	}
        /** 
         * Updates averages.
         * @param integer $student
         * @param integer $subject
         * @param integer $schoolyear
         * @param integer $semester
         * @param integer $date - the timelimit
         * @return integer 0 if success, no. of fails instead
         */
	public function updateAverages ($student,$subject,$schoolyear,$semester,$date) {
            $averages = Averages::model()->findAll(array(
                'condition'=>'date>:date AND student=:student AND subject=:subject AND schoolyear=:schoolyear AND semester=:semester',
                'params'=>array(
                    ':student'=>$student,
                    ':subject'=>$subject,
                    ':schoolyear'=>$schoolyear,
                    ':semester'=>$semester,
                    ':date'=>$date,
                ),
            ));
            //var_dump($averages);
            $ret=0;
            foreach ($averages as $avg) {
                $avg->updateAvg();
                if (!$avg->save()) $ret++;
            }
            return $ret;
        }
        /**
	 * Retrieves a list of models based on the current search/filter conditions.
	 * @return CActiveDataProvider the data provider that can return the models based on the search/filter conditions.
	 */
	public function search()
	{
		// Warning: Please modify the following code to remove attributes that
		// should not be searched.

		$criteria=new CDbCriteria;

		$criteria->compare('id',$this->id);
		$criteria->compare('subject',$this->subject);
		$criteria->compare('student',$this->student);
		$criteria->compare('schoolyear',$this->schoolyear);
		$criteria->compare('semester',$this->semester);
		$criteria->compare('added',$this->added,true);

		return new CActiveDataProvider(get_class($this), array(
			'criteria'=>$criteria,
		));
	}

        public function updateAvg() {
            $this->average=Mark::model()->getAverageStudentSubject($this->student, $this->subject, $this->schoolyear, $this->semester, $this->date);
        }
        
        protected function beforeSave () {
            if (parent::beforeSave()) {
                if ($this->isNewRecord) {
                    if ($this->type != self::TYPE_OFFICIAL)
                        $this->average=Mark::model()->getAverageStudentSubject($this->student, $this->subject, $this->schoolyear, $this->semester, $this->date);
                }
                return true;
            } else
                return false;
        }
        
        protected function afterSave () {
            parent::afterSave();
            $lastAverage = $this->find(array(
                'condition'=>'student=:student AND subject=:subject AND schoolyear=:schoolyear
                    AND semester=:semester AND added<:added',
                'params' => array(
                    ':student'=>$this->student,
                    ':subject'=>$this->subject,
                    ':schoolyear'=>$this->schoolyear,
                    ':semester'=>$this->semester,
                    ':added'=>$this->added,
                ),
            ));
            if ($lastAverage !== null) { // don't create any SMS draft at first mark
                if ($lastAverage->average - $this->average >= Averages::SMS_POINTS || 
                    $lastAverage->average >= Averages::LOW_AVERAGE && $this->average<Averages::LOW_AVERAGE)
                {
                    return Sms::model()->saveDraft($this->student, Sms::ADD_AVERAGE_LOW, array(
                        'subject'=>$this->subject,
                        'datestamp'=>$this->added,
                    ));
                }
            }
            return true;
        }
        
        protected function afterDelete() {
            parent::afterDelete();
            // SMSes are verified right before sending,
            //  so no worry to clean up something here
            return true;
        }
}